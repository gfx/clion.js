#!/usr/bin/env perl
use 5.14.0;
use strict;
use warnings FATAL => 'all';
use autodie;
use List::Util qw(max);
use Data::Dumper;
use Mouse ();

use FindBin qw($Bin);
use lib "$Bin/../ph";
BEGIN {
    $INC{'stdint.ph'}  = __FILE__;
    $INC{'stdio.ph'}   = __FILE__;
    $INC{'stdlib.ph'}  = __FILE__;
    $INC{'stdarg.ph'}  = __FILE__;
    $INC{'time.ph'}    = __FILE__;
    $INC{'pthread.ph'} = __FILE__;
    $INC{'glib.ph'}    = __FILE__;
    $INC{'config.ph'}  = __FILE__;
}
sub ph2js {
    my($pkg, $annotation, $prefix) = @_;
    my $C = Mouse::Meta::Class->initialize($pkg);

    my $get_value = sub {
        my($name) = @_;
        my $f = $C->get_method($name)->body;
        if(prototype($f) ~~ '') {
            return scalar eval { $f->() };
        }
        return undef;
    };

    my @names     = $C->get_method_list();
    @names = grep { /$prefix/ } @names if defined $prefix;

    my @constants =  grep { defined $_->[1] }
                     map  { [ $_, $get_value->($_) ] } @names;

    $_->[0] =~ s/^MONO_// for @constants;

    my $max_len = max map { length $_->[0] } @constants;
    @constants = sort { # sort by group
        my($a_group) = split /_/, $a->[0];
        my($b_group) = split /_/, $b->[0];

        $a_group cmp $b_group || $a->[1] <=> $b->[1] || $a->[0] cmp $b->[0];
    } @constants;

    say "// $annotation";
    foreach my $pair(@constants) {
        my($name, $value) = @{$pair};
        my $hex = sprintf '%x', $value;
        say sprintf '  %-*s: 0x%x, // %s', $max_len, $name,
            $value, $value;
    }
}


my $mono = <~/repo/mono>;
my $mono_metadata = "$mono/mono/metadata/metadata.c";
my $mono_tabledef = "$mono/mono/cil/tables.def";
my $mono_blob     = "$mono/mono/metadata/blob.h"; # MONO_TYPE_* and MONO_TABLE_*

=for comment

a TableSchema has: name, fields, typemap of fields

schema.name    :String
schema.fields  :Array
schema.field_type :HashMap

=cut

print <<HEAD;
/*
 This file is automatically generated by $0.
 */
// module meta
"use strict";
HEAD

print <<'GEN';
// auto-generated constants
/** @enum {int} */
var C = {
GEN

package C::metadata {
    require 'mono/metadata/metadata.ph';
    ::ph2js(__PACKAGE__, 'metadata.h', qr/^MONO_/);
}
ph2js('C::metadata', 'metadata.h', qr/^MONO_/);

package C::tokentype {
    require 'mono/metadata/tokentype.ph';
    ::ph2js(__PACKAGE__, 'tokentype.h', qr/^MONO_/);
}

package C::class_internals {
    require 'mono/metadata/class-internals.ph';
    ::ph2js(__PACKAGE__, 'class-internals.h', qr/^MONO_/);
}

package C::tabledefs {
    require 'mono/metadata/tabledefs.ph';
    ::ph2js(__PACKAGE__, 'tabledefs.h');
}

print <<'GEN';
}; // constants

GEN


sub make_enum {
    my($name, $init, @syms) = @_;

    printf <<'GEN', $name;
/** @enum {int} */
var %s = {
GEN
    my $max_len = max map { length } @syms;
    my $value = $init;
    foreach my $sym(@syms) {
        say sprintf '  %-*s: %d,', $max_len, $sym, $value++;
    }
    printf <<'GEN', $name;
}; // end of enum %s

GEN
}

make_enum('MetaType', 1, qw(
    UINT32
    UINT16
    UINT8

    BLOB_IDX
    STRING_IDX
    GUID_IDX
    TABLE_IDX
    CONST_IDX
    HASCAT_IDX
    CAT_IDX
    HASDEC_IDX
    IMPL_IDX
    HFM_IDX
    MF_IDX
    TDOR_IDX
    MRP_IDX
    MDOR_IDX
    HS_IDX
    RS_IDX
));

# parse Table Definitions
my @table_defs;
{
    open my $fh, '<', $mono_tabledef;
    while(<$fh>) {
        if(/MONO_(\w+), \s+ "(\w*)"/xms) {
            push @table_defs, [ $1, $2 ];
        }
    }
}


# Schemas of Each Table
my @schemas;
my %schema_of;
{
    my $c;
    open my $fh, '<', $mono_metadata;
    while(<$fh>) {
        last if /TableSchemas \s* \[\]/xms;
    }

    while(<$fh>) {
        last if /\};/;

        if(/\#define \s+ (\w+_OFFSET) \s+ (?: (\w+) \s+ \+ \s+)? (\d+)/xms) {
            my($name, $pre, $pre_elems) = ($1, $2, $3);
            my $offset = $pre_elems;
            $offset += $schema_of{$pre}{offset} if $pre;

            push @schemas, $schema_of{$name} = $c = {
                name => $name,
                offset => $offset,
                fields => [],
                field_of => {},
            };
        }
        elsif(m{MONO_MT_ (\w+), \s+ \/\* \s+ "([^\"]*)"}xms) {
            my($type, $name) = ($1, $2);
            push $c->{fields}, $name;
            $c->{field_type_of}{$name} = 'MetaType.' . $type;
        }
    }
}
# Mapping to Schema and Definition
my %description;
{
    my $c;
    open my $fh, '<', $mono_metadata;
    while(<$fh>) {
        last if /table_description \s* \[\]/xms;
    }

    my $idx = 0;
    while(<$fh>) {
        last if /\};/;

        if(/(\w+_SCHEMA_OFFSET)/xms) {
            $description{$idx++} = $1;
        }
    }
}
say '/** @const {Array} */';
say 'var TableSchema = [';
my $idx = 0;
foreach my $pair(@table_defs) {
    my($sym, $name) = @{$pair};
    my $schema_name = $description{$idx++} or die "no description entry for $sym";
    my $schema = $schema_of{$schema_name}  or die "no schema of $schema_name";
    say ' ' x 2, '{ // ', $sym;
    {
        say ' ' x 4, sprintf 'name: "%s",', $name;

        # fields
        say ' ' x 4, 'fields: [';
        foreach my $field(@{ $schema->{fields} }) {
            say ' ' x 6, sprintf '"%s",', $field;
        }
        say ' ' x 4., '],';

        # field_size
        say ' ' x 4, 'field_type: [';
        foreach my $field(@{ $schema->{fields} }) {
            say ' ' x 6, sprintf '%s,', $schema->{field_type_of}{$field};
        }
        say ' ' x 4., '],';
    }
    say ' ' x 2, '},';
}
say ']; // end of TableSchema';
print <<'FOOT';
exports.TableSchema = TableSchema;
exports.MetaType    = MetaType;
exports.C           = C;
FOOT
